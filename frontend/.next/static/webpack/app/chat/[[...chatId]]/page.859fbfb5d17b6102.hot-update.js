"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/[[...chatId]]/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteChat: function() { return /* binding */ deleteChat; },\n/* harmony export */   deleteDocument: function() { return /* binding */ deleteDocument; },\n/* harmony export */   exportChat: function() { return /* binding */ exportChat; },\n/* harmony export */   getChat: function() { return /* binding */ getChat; },\n/* harmony export */   getChats: function() { return /* binding */ getChats; },\n/* harmony export */   getDocument: function() { return /* binding */ getDocument; },\n/* harmony export */   getDocumentContent: function() { return /* binding */ getDocumentContent; },\n/* harmony export */   getDocuments: function() { return /* binding */ getDocuments; },\n/* harmony export */   getModels: function() { return /* binding */ getModels; },\n/* harmony export */   getPersonas: function() { return /* binding */ getPersonas; },\n/* harmony export */   getProviders: function() { return /* binding */ getProviders; },\n/* harmony export */   retryChat: function() { return /* binding */ retryChat; },\n/* harmony export */   saveChat: function() { return /* binding */ saveChat; },\n/* harmony export */   searchDocument: function() { return /* binding */ searchDocument; },\n/* harmony export */   sendChatMessage: function() { return /* binding */ sendChatMessage; },\n/* harmony export */   sendRagChatMessage: function() { return /* binding */ sendRagChatMessage; },\n/* harmony export */   updateChatTitle: function() { return /* binding */ updateChatTitle; },\n/* harmony export */   uploadDocument: function() { return /* binding */ uploadDocument; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: \"/api\",\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\n// Providers API\nconst getProviders = async ()=>{\n    try {\n        const response = await api.get(\"/providers\");\n        return response.data;\n    } catch (error) {\n        console.error(\"Error fetching providers:\", error);\n        // Return fallback data if backend is not available\n        return [\n            {\n                id: \"openai\",\n                name: \"OpenAI\",\n                website: \"https://openai.com\"\n            },\n            {\n                id: \"anthropic\",\n                name: \"Anthropic\",\n                website: \"https://anthropic.com\"\n            },\n            {\n                id: \"cohere\",\n                name: \"Cohere\",\n                website: \"https://cohere.com\"\n            },\n            {\n                id: \"mistral\",\n                name: \"Mistral AI\",\n                website: \"https://mistral.ai\"\n            },\n            {\n                id: \"groq\",\n                name: \"Groq\",\n                website: \"https://groq.com\"\n            }\n        ];\n    }\n};\n// Models API\nconst getModels = async (providerId)=>{\n    try {\n        const response = await api.get(\"/models?provider=\".concat(providerId));\n        return response.data;\n    } catch (error) {\n        console.error(\"Error fetching models:\", error);\n        // Return fallback data if backend is not available\n        return [\n            {\n                id: \"gpt-4o\",\n                name: \"GPT-4o\",\n                provider: \"openai\",\n                capabilities: [\n                    \"chat\",\n                    \"vision\"\n                ]\n            },\n            {\n                id: \"gpt-4-turbo\",\n                name: \"GPT-4 Turbo\",\n                provider: \"openai\",\n                capabilities: [\n                    \"chat\"\n                ]\n            },\n            {\n                id: \"gpt-4-o-mini\",\n                name: \"GPT-4o Mini\",\n                provider: \"openai\",\n                capabilities: [\n                    \"chat\"\n                ]\n            },\n            {\n                id: \"claude-3-opus\",\n                name: \"Claude 3 Opus\",\n                provider: \"anthropic\",\n                capabilities: [\n                    \"chat\",\n                    \"vision\"\n                ]\n            },\n            {\n                id: \"claude-3-sonnet\",\n                name: \"Claude 3 Sonnet\",\n                provider: \"anthropic\",\n                capabilities: [\n                    \"chat\",\n                    \"vision\"\n                ]\n            },\n            {\n                id: \"claude-3-haiku\",\n                name: \"Claude 3 Haiku\",\n                provider: \"anthropic\",\n                capabilities: [\n                    \"chat\",\n                    \"vision\"\n                ]\n            },\n            {\n                id: \"llama-3-70b-instruct\",\n                name: \"Llama 3 70B Instruct\",\n                provider: \"meta\",\n                capabilities: [\n                    \"chat\"\n                ]\n            },\n            {\n                id: \"mixtral-8x7b-instruct\",\n                name: \"Mixtral 8x7B Instruct\",\n                provider: \"mistral\",\n                capabilities: [\n                    \"chat\"\n                ]\n            },\n            {\n                id: \"gemini-1.5-pro\",\n                name: \"Gemini 1.5 Pro\",\n                provider: \"google\",\n                capabilities: [\n                    \"chat\",\n                    \"vision\"\n                ],\n                isPreview: true\n            }\n        ];\n    }\n};\n// Personas API\nconst getPersonas = async ()=>{\n    try {\n        const response = await api.get(\"/personas\");\n        return response.data;\n    } catch (error) {\n        console.error(\"Error fetching personas:\", error);\n        // Return fallback data if backend is not available\n        return [\n            {\n                id: \"1\",\n                name: \"Friendly Assistant\",\n                prompt: \"You are a friendly assistant.\"\n            },\n            {\n                id: \"2\",\n                name: \"Technical Expert\",\n                prompt: \"You are a technical expert.\"\n            },\n            {\n                id: \"3\",\n                name: \"Creative Writer\",\n                prompt: \"You are a creative writer.\"\n            },\n            {\n                id: \"4\",\n                name: \"Academic Assistant\",\n                prompt: \"You are an academic assistant.\"\n            },\n            {\n                id: \"5\",\n                name: \"Data Analyst\",\n                prompt: \"You are a data analyst.\"\n            }\n        ];\n    }\n};\n// Chat API\nconst sendChatMessage = async (content, chatId, provider, model, systemPrompt, temperature, maxTokens, continueMode)=>{\n    try {\n        const response = await api.post(\"/chat\", {\n            content,\n            chat_id: chatId,\n            provider,\n            model,\n            system_prompt: systemPrompt,\n            temperature,\n            max_tokens: maxTokens,\n            continue_mode: continueMode\n        });\n        // Extract the chat data from the response\n        const { chat_id, assistant_response } = response.data;\n        // Construct and return a Chat object with the messages\n        // This ensures the UI can properly update\n        const currentTimestamp = new Date().toISOString();\n        // Create a complete chat object for the UI to use\n        return {\n            chat_id: chat_id || chatId,\n            title: chatId ? undefined : content.substring(0, 30) + (content.length > 30 ? \"...\" : \"\"),\n            messages: [\n                // If there was a system prompt and this is a new chat, add it\n                ...systemPrompt && !chatId ? [\n                    {\n                        message_id: \"system-\".concat(Date.now()),\n                        role: \"system\",\n                        content: systemPrompt,\n                        created_at: currentTimestamp\n                    }\n                ] : [],\n                // Add the user message\n                {\n                    message_id: \"user-\".concat(Date.now()),\n                    role: \"user\",\n                    content,\n                    created_at: currentTimestamp\n                },\n                // Add the assistant response\n                {\n                    message_id: \"assistant-\".concat(Date.now()),\n                    role: \"assistant\",\n                    content: assistant_response,\n                    created_at: currentTimestamp\n                }\n            ],\n            provider: provider || \"openai\",\n            model: model || \"gpt-4o\",\n            system_prompt: systemPrompt,\n            created_at: currentTimestamp,\n            updated_at: currentTimestamp\n        };\n    } catch (error) {\n        console.error(\"Error sending chat message:\", error);\n        throw error;\n    }\n};\n// RAG Chat API\nconst sendRagChatMessage = async (content, documentIds, chatId, provider, model, systemPrompt, temperature, maxTokens)=>{\n    try {\n        const response = await api.post(\"/chat/rag\", {\n            content,\n            document_ids: documentIds,\n            chat_id: chatId,\n            provider,\n            model,\n            system_prompt: systemPrompt,\n            temperature,\n            max_tokens: maxTokens\n        });\n        // Extract the chat data from the response\n        const { chat_id, assistant_response } = response.data;\n        // Construct and return a Chat object with the messages\n        const currentTimestamp = new Date().toISOString();\n        // Create a complete chat object for the UI to use\n        return {\n            chat_id: chat_id || chatId,\n            title: chatId ? undefined : content.substring(0, 30) + (content.length > 30 ? \"...\" : \"\"),\n            messages: [\n                // If there was a system prompt and this is a new chat, add it\n                ...systemPrompt && !chatId ? [\n                    {\n                        message_id: \"system-\".concat(Date.now()),\n                        role: \"system\",\n                        content: systemPrompt,\n                        created_at: currentTimestamp\n                    }\n                ] : [],\n                // Add the user message\n                {\n                    message_id: \"user-\".concat(Date.now()),\n                    role: \"user\",\n                    content,\n                    created_at: currentTimestamp\n                },\n                // Add the assistant response\n                {\n                    message_id: \"assistant-\".concat(Date.now()),\n                    role: \"assistant\",\n                    content: assistant_response,\n                    created_at: currentTimestamp\n                }\n            ],\n            provider: provider || \"openai\",\n            model: model || \"gpt-4o\",\n            system_prompt: systemPrompt,\n            created_at: currentTimestamp,\n            updated_at: currentTimestamp,\n            document_ids: documentIds\n        };\n    } catch (error) {\n        console.error(\"Error sending RAG chat message:\", error);\n        throw error;\n    }\n};\n// Chats API\nconst getChats = async ()=>{\n    const response = await api.get(\"/chats\");\n    return response.data;\n};\nconst getChat = async (chatId)=>{\n    const response = await api.get(\"/chats/\".concat(chatId));\n    return response.data;\n};\nconst deleteChat = async (chatId)=>{\n    const response = await api.delete(\"/chats/\".concat(chatId));\n    return response.data;\n};\nconst updateChatTitle = async (chatId, title)=>{\n    const response = await api.put(\"/chats/\".concat(chatId, \"/title\"), {\n        title\n    });\n    return response.data;\n};\n// Export chat as JSON\nconst exportChat = async (chatId)=>{\n    // Just fetch the chat and return it for export\n    return getChat(chatId);\n};\n// Save chat (no-op, as saving is handled on backend)\nconst saveChat = async (chatId)=>{\n    // Optionally, you could call updateChatTitle or similar here\n    // For now, just return success\n    return {\n        success: true\n    };\n};\n// Retry chat (no-op, as retry logic is not defined)\nconst retryChat = async (chatId)=>{\n    // You could implement logic to re-send the last message if needed\n    // For now, just return success\n    return {\n        success: true\n    };\n};\n// Document API\nconst uploadDocument = async (file)=>{\n    const formData = new FormData();\n    formData.append(\"file\", file);\n    const response = await api.post(\"/documents/upload\", formData, {\n        headers: {\n            \"Content-Type\": \"multipart/form-data\"\n        }\n    });\n    return response.data;\n};\nconst getDocuments = async ()=>{\n    const response = await api.get(\"/documents\");\n    return response.data;\n};\nconst getDocument = async (docId)=>{\n    const response = await api.get(\"/documents/\".concat(docId));\n    return response.data;\n};\nconst searchDocument = async (docId, query)=>{\n    const response = await api.get(\"/documents/\".concat(docId, \"/search?query=\").concat(encodeURIComponent(query)));\n    return response.data;\n};\nconst deleteDocument = async (docId)=>{\n    await api.delete(\"/documents/\".concat(docId));\n};\nconst getDocumentContent = async (docId)=>{\n    const response = await api.get(\"/documents/\".concat(docId, \"/content\"));\n    return response.data;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFFMUIsTUFBTUMsTUFBTUQsNkNBQUtBLENBQUNFLE1BQU0sQ0FBQztJQUN2QkMsU0FBUztJQUNUQyxTQUFTO1FBQ1AsZ0JBQWdCO0lBQ2xCO0FBQ0Y7QUFzRUEsZ0JBQWdCO0FBQ1QsTUFBTUMsZUFBZTtJQUMxQixJQUFJO1FBQ0YsTUFBTUMsV0FBVyxNQUFNTCxJQUFJTSxHQUFHLENBQWE7UUFDM0MsT0FBT0QsU0FBU0UsSUFBSTtJQUN0QixFQUFFLE9BQU9DLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDZCQUE2QkE7UUFFM0MsbURBQW1EO1FBQ25ELE9BQU87WUFDTDtnQkFBRUUsSUFBSTtnQkFBVUMsTUFBTTtnQkFBVUMsU0FBUztZQUFxQjtZQUM5RDtnQkFBRUYsSUFBSTtnQkFBYUMsTUFBTTtnQkFBYUMsU0FBUztZQUF3QjtZQUN2RTtnQkFBRUYsSUFBSTtnQkFBVUMsTUFBTTtnQkFBVUMsU0FBUztZQUFxQjtZQUM5RDtnQkFBRUYsSUFBSTtnQkFBV0MsTUFBTTtnQkFBY0MsU0FBUztZQUFxQjtZQUNuRTtnQkFBRUYsSUFBSTtnQkFBUUMsTUFBTTtnQkFBUUMsU0FBUztZQUFtQjtTQUN6RDtJQUNIO0FBQ0YsRUFBRTtBQUVGLGFBQWE7QUFDTixNQUFNQyxZQUFZLE9BQU9DO0lBQzlCLElBQUk7UUFDRixNQUFNVCxXQUFXLE1BQU1MLElBQUlNLEdBQUcsQ0FBVSxvQkFBK0IsT0FBWFE7UUFDNUQsT0FBT1QsU0FBU0UsSUFBSTtJQUN0QixFQUFFLE9BQU9DLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDBCQUEwQkE7UUFFeEMsbURBQW1EO1FBQ25ELE9BQU87WUFDTDtnQkFDRUUsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkksVUFBVTtnQkFDVkMsY0FBYztvQkFBQztvQkFBUTtpQkFBUztZQUNsQztZQUNBO2dCQUNFTixJQUFJO2dCQUNKQyxNQUFNO2dCQUNOSSxVQUFVO2dCQUNWQyxjQUFjO29CQUFDO2lCQUFPO1lBQ3hCO1lBQ0E7Z0JBQ0VOLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05JLFVBQVU7Z0JBQ1ZDLGNBQWM7b0JBQUM7aUJBQU87WUFDeEI7WUFDQTtnQkFDRU4sSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkksVUFBVTtnQkFDVkMsY0FBYztvQkFBQztvQkFBUTtpQkFBUztZQUNsQztZQUNBO2dCQUNFTixJQUFJO2dCQUNKQyxNQUFNO2dCQUNOSSxVQUFVO2dCQUNWQyxjQUFjO29CQUFDO29CQUFRO2lCQUFTO1lBQ2xDO1lBQ0E7Z0JBQ0VOLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05JLFVBQVU7Z0JBQ1ZDLGNBQWM7b0JBQUM7b0JBQVE7aUJBQVM7WUFDbEM7WUFDQTtnQkFDRU4sSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkksVUFBVTtnQkFDVkMsY0FBYztvQkFBQztpQkFBTztZQUN4QjtZQUNBO2dCQUNFTixJQUFJO2dCQUNKQyxNQUFNO2dCQUNOSSxVQUFVO2dCQUNWQyxjQUFjO29CQUFDO2lCQUFPO1lBQ3hCO1lBQ0E7Z0JBQ0VOLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05JLFVBQVU7Z0JBQ1ZDLGNBQWM7b0JBQUM7b0JBQVE7aUJBQVM7Z0JBQ2hDQyxXQUFXO1lBQ2I7U0FDRDtJQUNIO0FBQ0YsRUFBRTtBQUVGLGVBQWU7QUFDUixNQUFNQyxjQUFjO0lBQ3pCLElBQUk7UUFDRixNQUFNYixXQUFXLE1BQU1MLElBQUlNLEdBQUcsQ0FBWTtRQUMxQyxPQUFPRCxTQUFTRSxJQUFJO0lBQ3RCLEVBQUUsT0FBT0MsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsNEJBQTRCQTtRQUUxQyxtREFBbUQ7UUFDbkQsT0FBTztZQUNMO2dCQUFFRSxJQUFJO2dCQUFLQyxNQUFNO2dCQUFzQlEsUUFBUTtZQUFnQztZQUMvRTtnQkFBRVQsSUFBSTtnQkFBS0MsTUFBTTtnQkFBb0JRLFFBQVE7WUFBOEI7WUFDM0U7Z0JBQUVULElBQUk7Z0JBQUtDLE1BQU07Z0JBQW1CUSxRQUFRO1lBQTZCO1lBQ3pFO2dCQUFFVCxJQUFJO2dCQUFLQyxNQUFNO2dCQUFzQlEsUUFBUTtZQUFpQztZQUNoRjtnQkFBRVQsSUFBSTtnQkFBS0MsTUFBTTtnQkFBZ0JRLFFBQVE7WUFBMEI7U0FDcEU7SUFDSDtBQUNGLEVBQUU7QUFFRixXQUFXO0FBQ0osTUFBTUMsa0JBQWtCLE9BQzdCQyxTQUNBQyxRQUNBUCxVQUNBUSxPQUNBQyxjQUNBQyxhQUNBQyxXQUNBQztJQUVBLElBQUk7UUFDRixNQUFNdEIsV0FBVyxNQUFNTCxJQUFJNEIsSUFBSSxDQUFDLFNBQVM7WUFDdkNQO1lBQ0FRLFNBQVNQO1lBQ1RQO1lBQ0FRO1lBQ0FPLGVBQWVOO1lBQ2ZDO1lBQ0FNLFlBQVlMO1lBQ1pNLGVBQWVMO1FBQ2pCO1FBRUEsMENBQTBDO1FBQzFDLE1BQU0sRUFBRUUsT0FBTyxFQUFFSSxrQkFBa0IsRUFBRSxHQUFHNUIsU0FBU0UsSUFBSTtRQUVyRCx1REFBdUQ7UUFDdkQsMENBQTBDO1FBQzFDLE1BQU0yQixtQkFBbUIsSUFBSUMsT0FBT0MsV0FBVztRQUUvQyxrREFBa0Q7UUFDbEQsT0FBTztZQUNMUCxTQUFTQSxXQUFXUDtZQUNwQmUsT0FBT2YsU0FBU2dCLFlBQVlqQixRQUFRa0IsU0FBUyxDQUFDLEdBQUcsTUFBT2xCLENBQUFBLFFBQVFtQixNQUFNLEdBQUcsS0FBSyxRQUFRLEVBQUM7WUFDdkZDLFVBQVU7Z0JBQ1IsOERBQThEO21CQUMxRGpCLGdCQUFnQixDQUFDRixTQUFTO29CQUFDO3dCQUM3Qm9CLFlBQVksVUFBcUIsT0FBWFAsS0FBS1EsR0FBRzt3QkFDOUJDLE1BQU07d0JBQ052QixTQUFTRzt3QkFDVHFCLFlBQVlYO29CQUNkO2lCQUFFLEdBQUcsRUFBRTtnQkFDUCx1QkFBdUI7Z0JBQ3ZCO29CQUNFUSxZQUFZLFFBQW1CLE9BQVhQLEtBQUtRLEdBQUc7b0JBQzVCQyxNQUFNO29CQUNOdkI7b0JBQ0F3QixZQUFZWDtnQkFDZDtnQkFDQSw2QkFBNkI7Z0JBQzdCO29CQUNFUSxZQUFZLGFBQXdCLE9BQVhQLEtBQUtRLEdBQUc7b0JBQ2pDQyxNQUFNO29CQUNOdkIsU0FBU1k7b0JBQ1RZLFlBQVlYO2dCQUNkO2FBQ0Q7WUFDRG5CLFVBQVVBLFlBQVk7WUFDdEJRLE9BQU9BLFNBQVM7WUFDaEJPLGVBQWVOO1lBQ2ZxQixZQUFZWDtZQUNaWSxZQUFZWjtRQUNkO0lBQ0YsRUFBRSxPQUFPMUIsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsK0JBQStCQTtRQUM3QyxNQUFNQTtJQUNSO0FBQ0YsRUFBRTtBQUVGLGVBQWU7QUFDUixNQUFNdUMscUJBQXFCLE9BQ2hDMUIsU0FDQTJCLGFBQ0ExQixRQUNBUCxVQUNBUSxPQUNBQyxjQUNBQyxhQUNBQztJQUVBLElBQUk7UUFDRixNQUFNckIsV0FBVyxNQUFNTCxJQUFJNEIsSUFBSSxDQUFDLGFBQWE7WUFDM0NQO1lBQ0E0QixjQUFjRDtZQUNkbkIsU0FBU1A7WUFDVFA7WUFDQVE7WUFDQU8sZUFBZU47WUFDZkM7WUFDQU0sWUFBWUw7UUFDZDtRQUVBLDBDQUEwQztRQUMxQyxNQUFNLEVBQUVHLE9BQU8sRUFBRUksa0JBQWtCLEVBQUUsR0FBRzVCLFNBQVNFLElBQUk7UUFFckQsdURBQXVEO1FBQ3ZELE1BQU0yQixtQkFBbUIsSUFBSUMsT0FBT0MsV0FBVztRQUUvQyxrREFBa0Q7UUFDbEQsT0FBTztZQUNMUCxTQUFTQSxXQUFXUDtZQUNwQmUsT0FBT2YsU0FBU2dCLFlBQVlqQixRQUFRa0IsU0FBUyxDQUFDLEdBQUcsTUFBT2xCLENBQUFBLFFBQVFtQixNQUFNLEdBQUcsS0FBSyxRQUFRLEVBQUM7WUFDdkZDLFVBQVU7Z0JBQ1IsOERBQThEO21CQUMxRGpCLGdCQUFnQixDQUFDRixTQUFTO29CQUFDO3dCQUM3Qm9CLFlBQVksVUFBcUIsT0FBWFAsS0FBS1EsR0FBRzt3QkFDOUJDLE1BQU07d0JBQ052QixTQUFTRzt3QkFDVHFCLFlBQVlYO29CQUNkO2lCQUFFLEdBQUcsRUFBRTtnQkFDUCx1QkFBdUI7Z0JBQ3ZCO29CQUNFUSxZQUFZLFFBQW1CLE9BQVhQLEtBQUtRLEdBQUc7b0JBQzVCQyxNQUFNO29CQUNOdkI7b0JBQ0F3QixZQUFZWDtnQkFDZDtnQkFDQSw2QkFBNkI7Z0JBQzdCO29CQUNFUSxZQUFZLGFBQXdCLE9BQVhQLEtBQUtRLEdBQUc7b0JBQ2pDQyxNQUFNO29CQUNOdkIsU0FBU1k7b0JBQ1RZLFlBQVlYO2dCQUNkO2FBQ0Q7WUFDRG5CLFVBQVVBLFlBQVk7WUFDdEJRLE9BQU9BLFNBQVM7WUFDaEJPLGVBQWVOO1lBQ2ZxQixZQUFZWDtZQUNaWSxZQUFZWjtZQUNaZSxjQUFjRDtRQUNoQjtJQUNGLEVBQUUsT0FBT3hDLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLG1DQUFtQ0E7UUFDakQsTUFBTUE7SUFDUjtBQUNGLEVBQUU7QUFFRixZQUFZO0FBQ0wsTUFBTTBDLFdBQVc7SUFDdEIsTUFBTTdDLFdBQVcsTUFBTUwsSUFBSU0sR0FBRyxDQUFnQjtJQUM5QyxPQUFPRCxTQUFTRSxJQUFJO0FBQ3RCLEVBQUU7QUFFSyxNQUFNNEMsVUFBVSxPQUFPN0I7SUFDNUIsTUFBTWpCLFdBQVcsTUFBTUwsSUFBSU0sR0FBRyxDQUFPLFVBQWlCLE9BQVBnQjtJQUMvQyxPQUFPakIsU0FBU0UsSUFBSTtBQUN0QixFQUFFO0FBRUssTUFBTTZDLGFBQWEsT0FBTzlCO0lBQy9CLE1BQU1qQixXQUFXLE1BQU1MLElBQUlxRCxNQUFNLENBQXVCLFVBQWlCLE9BQVAvQjtJQUNsRSxPQUFPakIsU0FBU0UsSUFBSTtBQUN0QixFQUFFO0FBRUssTUFBTStDLGtCQUFrQixPQUFPaEMsUUFBZ0JlO0lBQ3BELE1BQU1oQyxXQUFXLE1BQU1MLElBQUl1RCxHQUFHLENBQXVCLFVBQWlCLE9BQVBqQyxRQUFPLFdBQVM7UUFBRWU7SUFBTTtJQUN2RixPQUFPaEMsU0FBU0UsSUFBSTtBQUN0QixFQUFFO0FBRUYsc0JBQXNCO0FBQ2YsTUFBTWlELGFBQWEsT0FBT2xDO0lBQy9CLCtDQUErQztJQUMvQyxPQUFPNkIsUUFBUTdCO0FBQ2pCLEVBQUU7QUFFRixxREFBcUQ7QUFDOUMsTUFBTW1DLFdBQVcsT0FBT25DO0lBQzdCLDZEQUE2RDtJQUM3RCwrQkFBK0I7SUFDL0IsT0FBTztRQUFFb0MsU0FBUztJQUFLO0FBQ3pCLEVBQUU7QUFFRixvREFBb0Q7QUFDN0MsTUFBTUMsWUFBWSxPQUFPckM7SUFDOUIsa0VBQWtFO0lBQ2xFLCtCQUErQjtJQUMvQixPQUFPO1FBQUVvQyxTQUFTO0lBQUs7QUFDekIsRUFBRTtBQUVGLGVBQWU7QUFDUixNQUFNRSxpQkFBaUIsT0FBT0M7SUFDbkMsTUFBTUMsV0FBVyxJQUFJQztJQUNyQkQsU0FBU0UsTUFBTSxDQUFDLFFBQVFIO0lBRXhCLE1BQU14RCxXQUFXLE1BQU1MLElBQUk0QixJQUFJLENBQUMscUJBQXFCa0MsVUFBVTtRQUM3RDNELFNBQVM7WUFDUCxnQkFBZ0I7UUFDbEI7SUFDRjtJQUVBLE9BQU9FLFNBQVNFLElBQUk7QUFDdEIsRUFBRTtBQUVLLE1BQU0wRCxlQUFlO0lBQzFCLE1BQU01RCxXQUFXLE1BQU1MLElBQUlNLEdBQUcsQ0FBQztJQUMvQixPQUFPRCxTQUFTRSxJQUFJO0FBQ3RCLEVBQUU7QUFFSyxNQUFNMkQsY0FBYyxPQUFPQztJQUNoQyxNQUFNOUQsV0FBVyxNQUFNTCxJQUFJTSxHQUFHLENBQTBELGNBQW9CLE9BQU42RDtJQUN0RyxPQUFPOUQsU0FBU0UsSUFBSTtBQUN0QixFQUFFO0FBRUssTUFBTTZELGlCQUFpQixPQUFPRCxPQUFlRTtJQUNsRCxNQUFNaEUsV0FBVyxNQUFNTCxJQUFJTSxHQUFHLENBQzVCLGNBQW9DZ0UsT0FBdEJILE9BQU0sa0JBQTBDLE9BQTFCRyxtQkFBbUJEO0lBRXpELE9BQU9oRSxTQUFTRSxJQUFJO0FBQ3RCLEVBQUU7QUFFSyxNQUFNZ0UsaUJBQWlCLE9BQU9KO0lBQ25DLE1BQU1uRSxJQUFJcUQsTUFBTSxDQUFDLGNBQW9CLE9BQU5jO0FBQ2pDLEVBQUU7QUFFSyxNQUFNSyxxQkFBcUIsT0FBT0w7SUFDdkMsTUFBTTlELFdBQVcsTUFBTUwsSUFBSU0sR0FBRyxDQUFDLGNBQW9CLE9BQU42RCxPQUFNO0lBQ25ELE9BQU85RCxTQUFTRSxJQUFJO0FBQ3RCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9hcGkudHM/MmZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG5jb25zdCBhcGkgPSBheGlvcy5jcmVhdGUoe1xuICBiYXNlVVJMOiAnL2FwaScsXG4gIGhlYWRlcnM6IHtcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB9LFxufSk7XG5cbmV4cG9ydCB0eXBlIFByb3ZpZGVyID0ge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlZmF1bHQ/OiBib29sZWFuO1xuICBsb2dvVXJsPzogc3RyaW5nO1xuICB3ZWJzaXRlPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgTW9kZWwgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVmYXVsdD86IGJvb2xlYW47XG4gIHByb3ZpZGVyOiBzdHJpbmc7XG4gIGNhcGFiaWxpdGllczogc3RyaW5nW107XG4gIGVjb25vbWljYWw/OiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgUGVyc29uYSA9IHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBwcm9tcHQ6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIE1lc3NhZ2UgPSB7XG4gIG1lc3NhZ2VfaWQ6IHN0cmluZztcbiAgcm9sZTogJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JztcbiAgY29udGVudDogc3RyaW5nO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBDaGF0ID0ge1xuICBjaGF0X2lkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIHByb3ZpZGVyOiBzdHJpbmc7XG4gIG1vZGVsOiBzdHJpbmc7XG4gIHN5c3RlbV9wcm9tcHQ/OiBzdHJpbmc7XG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgdXBkYXRlZF9hdDogc3RyaW5nO1xuICBkb2N1bWVudF9pZHM/OiBzdHJpbmdbXTtcbn07XG5cbmV4cG9ydCB0eXBlIENoYXRTdW1tYXJ5ID0ge1xuICBjaGF0X2lkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcbiAgcHJvdmlkZXI6IHN0cmluZztcbiAgbW9kZWw6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50TWV0YWRhdGEgPSB7XG4gIGRvY19pZDogc3RyaW5nO1xuICBmaWxlbmFtZTogc3RyaW5nO1xuICBjaHVua19zaXplOiBudW1iZXI7XG4gIGNodW5rX292ZXJsYXA6IG51bWJlcjtcbiAgdG90YWxfY2h1bmtzOiBudW1iZXI7XG4gIHRvdGFsX2NoYXJzOiBudW1iZXI7XG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q2h1bmsgPSB7XG4gIGRvY19pZDogc3RyaW5nO1xuICBjaHVua19pZDogbnVtYmVyO1xuICBjb250ZW50OiBzdHJpbmc7XG4gIHN0YXJ0X2NoYXI6IG51bWJlcjtcbiAgZW5kX2NoYXI6IG51bWJlcjtcbn07XG5cbi8vIFByb3ZpZGVycyBBUElcbmV4cG9ydCBjb25zdCBnZXRQcm92aWRlcnMgPSBhc3luYyAoKTogUHJvbWlzZTxQcm92aWRlcltdPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0PFByb3ZpZGVyW10+KCcvcHJvdmlkZXJzJyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvdmlkZXJzOicsIGVycm9yKTtcblxuICAgIC8vIFJldHVybiBmYWxsYmFjayBkYXRhIGlmIGJhY2tlbmQgaXMgbm90IGF2YWlsYWJsZVxuICAgIHJldHVybiBbXG4gICAgICB7IGlkOiAnb3BlbmFpJywgbmFtZTogJ09wZW5BSScsIHdlYnNpdGU6ICdodHRwczovL29wZW5haS5jb20nIH0sXG4gICAgICB7IGlkOiAnYW50aHJvcGljJywgbmFtZTogJ0FudGhyb3BpYycsIHdlYnNpdGU6ICdodHRwczovL2FudGhyb3BpYy5jb20nIH0sXG4gICAgICB7IGlkOiAnY29oZXJlJywgbmFtZTogJ0NvaGVyZScsIHdlYnNpdGU6ICdodHRwczovL2NvaGVyZS5jb20nIH0sXG4gICAgICB7IGlkOiAnbWlzdHJhbCcsIG5hbWU6ICdNaXN0cmFsIEFJJywgd2Vic2l0ZTogJ2h0dHBzOi8vbWlzdHJhbC5haScgfSxcbiAgICAgIHsgaWQ6ICdncm9xJywgbmFtZTogJ0dyb3EnLCB3ZWJzaXRlOiAnaHR0cHM6Ly9ncm9xLmNvbScgfVxuICAgIF07XG4gIH1cbn07XG5cbi8vIE1vZGVscyBBUElcbmV4cG9ydCBjb25zdCBnZXRNb2RlbHMgPSBhc3luYyAocHJvdmlkZXJJZDogc3RyaW5nKTogUHJvbWlzZTxNb2RlbFtdPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0PE1vZGVsW10+KGAvbW9kZWxzP3Byb3ZpZGVyPSR7cHJvdmlkZXJJZH1gKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBtb2RlbHM6JywgZXJyb3IpO1xuXG4gICAgLy8gUmV0dXJuIGZhbGxiYWNrIGRhdGEgaWYgYmFja2VuZCBpcyBub3QgYXZhaWxhYmxlXG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgaWQ6ICdncHQtNG8nLFxuICAgICAgICBuYW1lOiAnR1BULTRvJyxcbiAgICAgICAgcHJvdmlkZXI6ICdvcGVuYWknLFxuICAgICAgICBjYXBhYmlsaXRpZXM6IFsnY2hhdCcsICd2aXNpb24nXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6ICdncHQtNC10dXJibycsXG4gICAgICAgIG5hbWU6ICdHUFQtNCBUdXJibycsXG4gICAgICAgIHByb3ZpZGVyOiAnb3BlbmFpJyxcbiAgICAgICAgY2FwYWJpbGl0aWVzOiBbJ2NoYXQnXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6ICdncHQtNC1vLW1pbmknLFxuICAgICAgICBuYW1lOiAnR1BULTRvIE1pbmknLFxuICAgICAgICBwcm92aWRlcjogJ29wZW5haScsXG4gICAgICAgIGNhcGFiaWxpdGllczogWydjaGF0J11cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiAnY2xhdWRlLTMtb3B1cycsXG4gICAgICAgIG5hbWU6ICdDbGF1ZGUgMyBPcHVzJyxcbiAgICAgICAgcHJvdmlkZXI6ICdhbnRocm9waWMnLFxuICAgICAgICBjYXBhYmlsaXRpZXM6IFsnY2hhdCcsICd2aXNpb24nXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6ICdjbGF1ZGUtMy1zb25uZXQnLFxuICAgICAgICBuYW1lOiAnQ2xhdWRlIDMgU29ubmV0JyxcbiAgICAgICAgcHJvdmlkZXI6ICdhbnRocm9waWMnLFxuICAgICAgICBjYXBhYmlsaXRpZXM6IFsnY2hhdCcsICd2aXNpb24nXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6ICdjbGF1ZGUtMy1oYWlrdScsXG4gICAgICAgIG5hbWU6ICdDbGF1ZGUgMyBIYWlrdScsXG4gICAgICAgIHByb3ZpZGVyOiAnYW50aHJvcGljJyxcbiAgICAgICAgY2FwYWJpbGl0aWVzOiBbJ2NoYXQnLCAndmlzaW9uJ11cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiAnbGxhbWEtMy03MGItaW5zdHJ1Y3QnLFxuICAgICAgICBuYW1lOiAnTGxhbWEgMyA3MEIgSW5zdHJ1Y3QnLFxuICAgICAgICBwcm92aWRlcjogJ21ldGEnLFxuICAgICAgICBjYXBhYmlsaXRpZXM6IFsnY2hhdCddXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJ21peHRyYWwtOHg3Yi1pbnN0cnVjdCcsXG4gICAgICAgIG5hbWU6ICdNaXh0cmFsIDh4N0IgSW5zdHJ1Y3QnLFxuICAgICAgICBwcm92aWRlcjogJ21pc3RyYWwnLFxuICAgICAgICBjYXBhYmlsaXRpZXM6IFsnY2hhdCddXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJ2dlbWluaS0xLjUtcHJvJyxcbiAgICAgICAgbmFtZTogJ0dlbWluaSAxLjUgUHJvJyxcbiAgICAgICAgcHJvdmlkZXI6ICdnb29nbGUnLFxuICAgICAgICBjYXBhYmlsaXRpZXM6IFsnY2hhdCcsICd2aXNpb24nXSxcbiAgICAgICAgaXNQcmV2aWV3OiB0cnVlXG4gICAgICB9XG4gICAgXTtcbiAgfVxufTtcblxuLy8gUGVyc29uYXMgQVBJXG5leHBvcnQgY29uc3QgZ2V0UGVyc29uYXMgPSBhc3luYyAoKTogUHJvbWlzZTxQZXJzb25hW10+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQ8UGVyc29uYVtdPignL3BlcnNvbmFzJyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcGVyc29uYXM6JywgZXJyb3IpO1xuXG4gICAgLy8gUmV0dXJuIGZhbGxiYWNrIGRhdGEgaWYgYmFja2VuZCBpcyBub3QgYXZhaWxhYmxlXG4gICAgcmV0dXJuIFtcbiAgICAgIHsgaWQ6ICcxJywgbmFtZTogJ0ZyaWVuZGx5IEFzc2lzdGFudCcsIHByb21wdDogJ1lvdSBhcmUgYSBmcmllbmRseSBhc3Npc3RhbnQuJyB9LFxuICAgICAgeyBpZDogJzInLCBuYW1lOiAnVGVjaG5pY2FsIEV4cGVydCcsIHByb21wdDogJ1lvdSBhcmUgYSB0ZWNobmljYWwgZXhwZXJ0LicgfSxcbiAgICAgIHsgaWQ6ICczJywgbmFtZTogJ0NyZWF0aXZlIFdyaXRlcicsIHByb21wdDogJ1lvdSBhcmUgYSBjcmVhdGl2ZSB3cml0ZXIuJyB9LFxuICAgICAgeyBpZDogJzQnLCBuYW1lOiAnQWNhZGVtaWMgQXNzaXN0YW50JywgcHJvbXB0OiAnWW91IGFyZSBhbiBhY2FkZW1pYyBhc3Npc3RhbnQuJyB9LFxuICAgICAgeyBpZDogJzUnLCBuYW1lOiAnRGF0YSBBbmFseXN0JywgcHJvbXB0OiAnWW91IGFyZSBhIGRhdGEgYW5hbHlzdC4nIH1cbiAgICBdO1xuICB9XG59O1xuXG4vLyBDaGF0IEFQSVxuZXhwb3J0IGNvbnN0IHNlbmRDaGF0TWVzc2FnZSA9IGFzeW5jIChcbiAgY29udGVudDogc3RyaW5nLFxuICBjaGF0SWQ/OiBzdHJpbmcsXG4gIHByb3ZpZGVyPzogc3RyaW5nLFxuICBtb2RlbD86IHN0cmluZyxcbiAgc3lzdGVtUHJvbXB0Pzogc3RyaW5nLFxuICB0ZW1wZXJhdHVyZT86IG51bWJlcixcbiAgbWF4VG9rZW5zPzogbnVtYmVyLFxuICBjb250aW51ZU1vZGU/OiBib29sZWFuXG4pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvY2hhdCcsIHtcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjaGF0X2lkOiBjaGF0SWQsXG4gICAgICBwcm92aWRlcixcbiAgICAgIG1vZGVsLFxuICAgICAgc3lzdGVtX3Byb21wdDogc3lzdGVtUHJvbXB0LFxuICAgICAgdGVtcGVyYXR1cmUsXG4gICAgICBtYXhfdG9rZW5zOiBtYXhUb2tlbnMsXG4gICAgICBjb250aW51ZV9tb2RlOiBjb250aW51ZU1vZGUsXG4gICAgfSk7XG5cbiAgICAvLyBFeHRyYWN0IHRoZSBjaGF0IGRhdGEgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICBjb25zdCB7IGNoYXRfaWQsIGFzc2lzdGFudF9yZXNwb25zZSB9ID0gcmVzcG9uc2UuZGF0YTtcblxuICAgIC8vIENvbnN0cnVjdCBhbmQgcmV0dXJuIGEgQ2hhdCBvYmplY3Qgd2l0aCB0aGUgbWVzc2FnZXNcbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIFVJIGNhbiBwcm9wZXJseSB1cGRhdGVcbiAgICBjb25zdCBjdXJyZW50VGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuXG4gICAgLy8gQ3JlYXRlIGEgY29tcGxldGUgY2hhdCBvYmplY3QgZm9yIHRoZSBVSSB0byB1c2VcbiAgICByZXR1cm4ge1xuICAgICAgY2hhdF9pZDogY2hhdF9pZCB8fCBjaGF0SWQsXG4gICAgICB0aXRsZTogY2hhdElkID8gdW5kZWZpbmVkIDogY29udGVudC5zdWJzdHJpbmcoMCwgMzApICsgKGNvbnRlbnQubGVuZ3RoID4gMzAgPyAnLi4uJyA6ICcnKSxcbiAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHN5c3RlbSBwcm9tcHQgYW5kIHRoaXMgaXMgYSBuZXcgY2hhdCwgYWRkIGl0XG4gICAgICAgIC4uLihzeXN0ZW1Qcm9tcHQgJiYgIWNoYXRJZCA/IFt7XG4gICAgICAgICAgbWVzc2FnZV9pZDogYHN5c3RlbS0ke0RhdGUubm93KCl9YCxcbiAgICAgICAgICByb2xlOiAnc3lzdGVtJyBhcyBjb25zdCxcbiAgICAgICAgICBjb250ZW50OiBzeXN0ZW1Qcm9tcHQsXG4gICAgICAgICAgY3JlYXRlZF9hdDogY3VycmVudFRpbWVzdGFtcFxuICAgICAgICB9XSA6IFtdKSxcbiAgICAgICAgLy8gQWRkIHRoZSB1c2VyIG1lc3NhZ2VcbiAgICAgICAge1xuICAgICAgICAgIG1lc3NhZ2VfaWQ6IGB1c2VyLSR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgIHJvbGU6ICd1c2VyJyBhcyBjb25zdCxcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IGN1cnJlbnRUaW1lc3RhbXBcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQWRkIHRoZSBhc3Npc3RhbnQgcmVzcG9uc2VcbiAgICAgICAge1xuICAgICAgICAgIG1lc3NhZ2VfaWQ6IGBhc3Npc3RhbnQtJHtEYXRlLm5vdygpfWAsXG4gICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcgYXMgY29uc3QsXG4gICAgICAgICAgY29udGVudDogYXNzaXN0YW50X3Jlc3BvbnNlLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IGN1cnJlbnRUaW1lc3RhbXBcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHByb3ZpZGVyOiBwcm92aWRlciB8fCAnb3BlbmFpJyxcbiAgICAgIG1vZGVsOiBtb2RlbCB8fCAnZ3B0LTRvJyxcbiAgICAgIHN5c3RlbV9wcm9tcHQ6IHN5c3RlbVByb21wdCxcbiAgICAgIGNyZWF0ZWRfYXQ6IGN1cnJlbnRUaW1lc3RhbXAsXG4gICAgICB1cGRhdGVkX2F0OiBjdXJyZW50VGltZXN0YW1wXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZW5kaW5nIGNoYXQgbWVzc2FnZTonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIFJBRyBDaGF0IEFQSVxuZXhwb3J0IGNvbnN0IHNlbmRSYWdDaGF0TWVzc2FnZSA9IGFzeW5jIChcbiAgY29udGVudDogc3RyaW5nLFxuICBkb2N1bWVudElkczogc3RyaW5nW10sXG4gIGNoYXRJZD86IHN0cmluZyxcbiAgcHJvdmlkZXI/OiBzdHJpbmcsXG4gIG1vZGVsPzogc3RyaW5nLFxuICBzeXN0ZW1Qcm9tcHQ/OiBzdHJpbmcsXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyLFxuICBtYXhUb2tlbnM/OiBudW1iZXJcbikgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9jaGF0L3JhZycsIHtcbiAgICAgIGNvbnRlbnQsXG4gICAgICBkb2N1bWVudF9pZHM6IGRvY3VtZW50SWRzLFxuICAgICAgY2hhdF9pZDogY2hhdElkLFxuICAgICAgcHJvdmlkZXIsXG4gICAgICBtb2RlbCxcbiAgICAgIHN5c3RlbV9wcm9tcHQ6IHN5c3RlbVByb21wdCxcbiAgICAgIHRlbXBlcmF0dXJlLFxuICAgICAgbWF4X3Rva2VuczogbWF4VG9rZW5zLFxuICAgIH0pO1xuXG4gICAgLy8gRXh0cmFjdCB0aGUgY2hhdCBkYXRhIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgY29uc3QgeyBjaGF0X2lkLCBhc3Npc3RhbnRfcmVzcG9uc2UgfSA9IHJlc3BvbnNlLmRhdGE7XG5cbiAgICAvLyBDb25zdHJ1Y3QgYW5kIHJldHVybiBhIENoYXQgb2JqZWN0IHdpdGggdGhlIG1lc3NhZ2VzXG4gICAgY29uc3QgY3VycmVudFRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcblxuICAgIC8vIENyZWF0ZSBhIGNvbXBsZXRlIGNoYXQgb2JqZWN0IGZvciB0aGUgVUkgdG8gdXNlXG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYXRfaWQ6IGNoYXRfaWQgfHwgY2hhdElkLFxuICAgICAgdGl0bGU6IGNoYXRJZCA/IHVuZGVmaW5lZCA6IGNvbnRlbnQuc3Vic3RyaW5nKDAsIDMwKSArIChjb250ZW50Lmxlbmd0aCA+IDMwID8gJy4uLicgOiAnJyksXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBzeXN0ZW0gcHJvbXB0IGFuZCB0aGlzIGlzIGEgbmV3IGNoYXQsIGFkZCBpdFxuICAgICAgICAuLi4oc3lzdGVtUHJvbXB0ICYmICFjaGF0SWQgPyBbe1xuICAgICAgICAgIG1lc3NhZ2VfaWQ6IGBzeXN0ZW0tJHtEYXRlLm5vdygpfWAsXG4gICAgICAgICAgcm9sZTogJ3N5c3RlbScgYXMgY29uc3QsXG4gICAgICAgICAgY29udGVudDogc3lzdGVtUHJvbXB0LFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IGN1cnJlbnRUaW1lc3RhbXBcbiAgICAgICAgfV0gOiBbXSksXG4gICAgICAgIC8vIEFkZCB0aGUgdXNlciBtZXNzYWdlXG4gICAgICAgIHtcbiAgICAgICAgICBtZXNzYWdlX2lkOiBgdXNlci0ke0RhdGUubm93KCl9YCxcbiAgICAgICAgICByb2xlOiAndXNlcicgYXMgY29uc3QsXG4gICAgICAgICAgY29udGVudCxcbiAgICAgICAgICBjcmVhdGVkX2F0OiBjdXJyZW50VGltZXN0YW1wXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFkZCB0aGUgYXNzaXN0YW50IHJlc3BvbnNlXG4gICAgICAgIHtcbiAgICAgICAgICBtZXNzYWdlX2lkOiBgYXNzaXN0YW50LSR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnIGFzIGNvbnN0LFxuICAgICAgICAgIGNvbnRlbnQ6IGFzc2lzdGFudF9yZXNwb25zZSxcbiAgICAgICAgICBjcmVhdGVkX2F0OiBjdXJyZW50VGltZXN0YW1wXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBwcm92aWRlcjogcHJvdmlkZXIgfHwgJ29wZW5haScsXG4gICAgICBtb2RlbDogbW9kZWwgfHwgJ2dwdC00bycsXG4gICAgICBzeXN0ZW1fcHJvbXB0OiBzeXN0ZW1Qcm9tcHQsXG4gICAgICBjcmVhdGVkX2F0OiBjdXJyZW50VGltZXN0YW1wLFxuICAgICAgdXBkYXRlZF9hdDogY3VycmVudFRpbWVzdGFtcCxcbiAgICAgIGRvY3VtZW50X2lkczogZG9jdW1lbnRJZHNcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNlbmRpbmcgUkFHIGNoYXQgbWVzc2FnZTonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIENoYXRzIEFQSVxuZXhwb3J0IGNvbnN0IGdldENoYXRzID0gYXN5bmMgKCk6IFByb21pc2U8Q2hhdFN1bW1hcnlbXT4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQ8Q2hhdFN1bW1hcnlbXT4oJy9jaGF0cycpO1xuICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDaGF0ID0gYXN5bmMgKGNoYXRJZDogc3RyaW5nKTogUHJvbWlzZTxDaGF0PiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldDxDaGF0PihgL2NoYXRzLyR7Y2hhdElkfWApO1xuICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWxldGVDaGF0ID0gYXN5bmMgKGNoYXRJZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5kZWxldGU8eyBzdWNjZXNzOiBib29sZWFuIH0+KGAvY2hhdHMvJHtjaGF0SWR9YCk7XG4gIHJldHVybiByZXNwb25zZS5kYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUNoYXRUaXRsZSA9IGFzeW5jIChjaGF0SWQ6IHN0cmluZywgdGl0bGU6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuIH0+ID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucHV0PHsgc3VjY2VzczogYm9vbGVhbiB9PihgL2NoYXRzLyR7Y2hhdElkfS90aXRsZWAsIHsgdGl0bGUgfSk7XG4gIHJldHVybiByZXNwb25zZS5kYXRhO1xufTtcblxuLy8gRXhwb3J0IGNoYXQgYXMgSlNPTlxuZXhwb3J0IGNvbnN0IGV4cG9ydENoYXQgPSBhc3luYyAoY2hhdElkOiBzdHJpbmcpOiBQcm9taXNlPENoYXQ+ID0+IHtcbiAgLy8gSnVzdCBmZXRjaCB0aGUgY2hhdCBhbmQgcmV0dXJuIGl0IGZvciBleHBvcnRcbiAgcmV0dXJuIGdldENoYXQoY2hhdElkKTtcbn07XG5cbi8vIFNhdmUgY2hhdCAobm8tb3AsIGFzIHNhdmluZyBpcyBoYW5kbGVkIG9uIGJhY2tlbmQpXG5leHBvcnQgY29uc3Qgc2F2ZUNoYXQgPSBhc3luYyAoY2hhdElkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiA9PiB7XG4gIC8vIE9wdGlvbmFsbHksIHlvdSBjb3VsZCBjYWxsIHVwZGF0ZUNoYXRUaXRsZSBvciBzaW1pbGFyIGhlcmVcbiAgLy8gRm9yIG5vdywganVzdCByZXR1cm4gc3VjY2Vzc1xuICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG59O1xuXG4vLyBSZXRyeSBjaGF0IChuby1vcCwgYXMgcmV0cnkgbG9naWMgaXMgbm90IGRlZmluZWQpXG5leHBvcnQgY29uc3QgcmV0cnlDaGF0ID0gYXN5bmMgKGNoYXRJZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4gPT4ge1xuICAvLyBZb3UgY291bGQgaW1wbGVtZW50IGxvZ2ljIHRvIHJlLXNlbmQgdGhlIGxhc3QgbWVzc2FnZSBpZiBuZWVkZWRcbiAgLy8gRm9yIG5vdywganVzdCByZXR1cm4gc3VjY2Vzc1xuICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG59O1xuXG4vLyBEb2N1bWVudCBBUElcbmV4cG9ydCBjb25zdCB1cGxvYWREb2N1bWVudCA9IGFzeW5jIChmaWxlOiBGaWxlKTogUHJvbWlzZTx7IGRvY19pZDogc3RyaW5nIH0+ID0+IHtcbiAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgZmlsZSk7XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2RvY3VtZW50cy91cGxvYWQnLCBmb3JtRGF0YSwge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXG4gICAgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0RG9jdW1lbnRzID0gYXN5bmMgKCk6IFByb21pc2U8RG9jdW1lbnRNZXRhZGF0YVtdPiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2RvY3VtZW50cycpO1xuICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXREb2N1bWVudCA9IGFzeW5jIChkb2NJZDogc3RyaW5nKTogUHJvbWlzZTx7IG1ldGFkYXRhOiBEb2N1bWVudE1ldGFkYXRhOyBjaHVua3M6IERvY3VtZW50Q2h1bmtbXSB9PiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldDx7IG1ldGFkYXRhOiBEb2N1bWVudE1ldGFkYXRhOyBjaHVua3M6IERvY3VtZW50Q2h1bmtbXSB9PihgL2RvY3VtZW50cy8ke2RvY0lkfWApO1xuICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBzZWFyY2hEb2N1bWVudCA9IGFzeW5jIChkb2NJZDogc3RyaW5nLCBxdWVyeTogc3RyaW5nKTogUHJvbWlzZTx7IGRvY3VtZW50OiBEb2N1bWVudE1ldGFkYXRhOyByZXN1bHRzOiBEb2N1bWVudENodW5rW10gfT4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQ8eyBkb2N1bWVudDogRG9jdW1lbnRNZXRhZGF0YTsgcmVzdWx0czogRG9jdW1lbnRDaHVua1tdIH0+KFxuICAgIGAvZG9jdW1lbnRzLyR7ZG9jSWR9L3NlYXJjaD9xdWVyeT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9YFxuICApO1xuICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWxldGVEb2N1bWVudCA9IGFzeW5jIChkb2NJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGF3YWl0IGFwaS5kZWxldGUoYC9kb2N1bWVudHMvJHtkb2NJZH1gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXREb2N1bWVudENvbnRlbnQgPSBhc3luYyAoZG9jSWQ6IHN0cmluZyk6IFByb21pc2U8eyBjb250ZW50OiBzdHJpbmcgfT4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoYC9kb2N1bWVudHMvJHtkb2NJZH0vY29udGVudGApO1xuICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbn07Il0sIm5hbWVzIjpbImF4aW9zIiwiYXBpIiwiY3JlYXRlIiwiYmFzZVVSTCIsImhlYWRlcnMiLCJnZXRQcm92aWRlcnMiLCJyZXNwb25zZSIsImdldCIsImRhdGEiLCJlcnJvciIsImNvbnNvbGUiLCJpZCIsIm5hbWUiLCJ3ZWJzaXRlIiwiZ2V0TW9kZWxzIiwicHJvdmlkZXJJZCIsInByb3ZpZGVyIiwiY2FwYWJpbGl0aWVzIiwiaXNQcmV2aWV3IiwiZ2V0UGVyc29uYXMiLCJwcm9tcHQiLCJzZW5kQ2hhdE1lc3NhZ2UiLCJjb250ZW50IiwiY2hhdElkIiwibW9kZWwiLCJzeXN0ZW1Qcm9tcHQiLCJ0ZW1wZXJhdHVyZSIsIm1heFRva2VucyIsImNvbnRpbnVlTW9kZSIsInBvc3QiLCJjaGF0X2lkIiwic3lzdGVtX3Byb21wdCIsIm1heF90b2tlbnMiLCJjb250aW51ZV9tb2RlIiwiYXNzaXN0YW50X3Jlc3BvbnNlIiwiY3VycmVudFRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInRpdGxlIiwidW5kZWZpbmVkIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwibWVzc2FnZXMiLCJtZXNzYWdlX2lkIiwibm93Iiwicm9sZSIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0Iiwic2VuZFJhZ0NoYXRNZXNzYWdlIiwiZG9jdW1lbnRJZHMiLCJkb2N1bWVudF9pZHMiLCJnZXRDaGF0cyIsImdldENoYXQiLCJkZWxldGVDaGF0IiwiZGVsZXRlIiwidXBkYXRlQ2hhdFRpdGxlIiwicHV0IiwiZXhwb3J0Q2hhdCIsInNhdmVDaGF0Iiwic3VjY2VzcyIsInJldHJ5Q2hhdCIsInVwbG9hZERvY3VtZW50IiwiZmlsZSIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJnZXREb2N1bWVudHMiLCJnZXREb2N1bWVudCIsImRvY0lkIiwic2VhcmNoRG9jdW1lbnQiLCJxdWVyeSIsImVuY29kZVVSSUNvbXBvbmVudCIsImRlbGV0ZURvY3VtZW50IiwiZ2V0RG9jdW1lbnRDb250ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});